> :- backchain h/1.
| :- backchain g/1.
| :- backchain f/1.
| h(X) += g(X)/2.
| h(X) += f(X)/2.
| a(X) = h(X) for X in range(6).
|
| g(X) = X*f(X-1) for X > 0.
| f(X) = X*g(X-1) for X > 0.
| f(0) = 1.
| g(0) = 1.
| c(X) = (f(X) + g(X)) / 2 for X in range(1,6).  % skip the base case.

Changes
=======
a(0) = 1.0.
a(1) = 1.0.
a(2) = 2.0.
a(3) = 6.0.
a(4) = 24.0.
a(5) = 120.0.
c(1) = 1.0.
c(2) = 2.0.
c(3) = 6.0.
c(4) = 24.0.
c(5) = 120.0.

> rules

Rules
=====
  0: h(X) += g(X)/2.
  1: h(X) += f(X)/2.
  2: a(X) = h(X) for X in range(6).
  3: g(X) = X*f(X-1) for X > 0.
  4: f(X) = X*g(X-1) for X > 0.
  5: f(0) = 1.
  6: g(0) = 1.
  7: c(X) = (f(X) + g(X)) / 2 for X in range(1,6).

> retract_rule 3

Changes
=======
c(1) = null.
c(2) = null.
c(3) = null.
c(4) = null.
c(5) = null.
g(1) = null.
g(2) = null.
g(3) = null.
g(4) = null.
g(5) = null.

% as in `retract-bc.dynadoc`, `a(X)` did not change even tho it ought to. The
% `c(X)` values get blasted because the don't have an oblivious memoized item
% inbetween like `h(X)`.

> b(X) = h(X) for X in range(6).

Changes
=======
b(0) = 1.0.
b(1) = 1.0.
b(2) = 2.0.
b(3) = 6.0.
b(4) = 24.0.
b(5) = 120.0.

% Just to hammer the point home, the rule above shows that `h(X)` values are
% still memoized! It doesn't know that one of it's antecedents has changed.

> sol

Solution
========
a/1
===
a(0) = 1.0.
a(1) = 1.0.
a(2) = 2.0.
a(3) = 6.0.
a(4) = 24.0.
a(5) = 120.0.

b/1
===
b(0) = 1.0.
b(1) = 1.0.
b(2) = 2.0.
b(3) = 6.0.
b(4) = 24.0.
b(5) = 120.0.

% TODO: redefine `g` see if the other rules pick up the new definition.
